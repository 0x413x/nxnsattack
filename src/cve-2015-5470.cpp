#include "dns.hpp"
#include <cstdio>
#include <cstring>
#include <vector>
#include <string>
#include <sstream>
#include <stdexcept>
#include <iostream>
#include <algorithm>
#include <iterator>
#include <arpa/inet.h>
#include <unistd.h>
#include <boost/cstdint.hpp>
#include <boost/shared_ptr.hpp>
#include <boost/numeric/conversion/cast.hpp>
#include <boost/thread.hpp>

const char *DNS_SERVER_ADDRESS = "192.168.33.13";
const int MAX_THREADS = 1;


void query( const std::string &qname )
{
    dns::PacketInfo query;
    query.id                   = rand()&0xffff;
    query.opcode               = 0;
    query.query_response       = 0;
    query.authoritative_answer = 0;
    query.truncation           = 0;
    query.recursion_desired    = 1;
    query.recursion_available  = 0;
    query.zero_field           = 0;
    query.authentic_data       = 0;
    query.checking_disabled    = 0;
    query.response_code        = 0;

    dns::QuestionSectionEntry question;
    question.q_domainname = qname;
    question.q_type       = dns::TYPE_A;
    question.q_class      = dns::CLASS_IN;
    question.q_offset     = 0xffff;
    query.question_section.push_back( question );

    WireFormat message;
    dns::generate_dns_packet( query, message );
    std::vector<uint8_t> packet_data = message.get();
    
    int tcp_socket = socket( AF_INET, SOCK_STREAM, IPPROTO_TCP );
    if ( tcp_socket < 0 ) {
	std::cerr << "cannot create socket" << std::endl;
	std::exit( 1 );
    }

    in_addr server_address;
    if ( inet_pton( AF_INET, DNS_SERVER_ADDRESS, &server_address ) <= 0 ) {
	std::cerr << "cannot convert dns server address" << std::endl;
	std::exit( 1 );
    }

    sockaddr_in socket_address;
    std::memset( &socket_address, 0, sizeof(socket_address) );
    socket_address.sin_family = AF_INET;
    socket_address.sin_addr   = server_address;
    socket_address.sin_port   = htons( 53 );
    if ( connect( tcp_socket, reinterpret_cast<const sockaddr *>( &socket_address ), sizeof(socket_address) ) < 0 ) {
	close( tcp_socket );
	std::cerr << "cannot connect to dns server" << std::endl;
	std::exit( 1 );
    }

    boost::uint16_t query_size = htons( boost::numeric_cast<boost::uint16_t>( packet_data.size() ) );
    int sent_size = write( tcp_socket, &query_size, sizeof(query_size) );
    if ( sent_size < 0 ) {
	std::cerr << "cannot end query length" << std::endl;
	std::exit( 1 );
    }
    sent_size = write( tcp_socket, &packet_data[0], packet_data.size() );
    if ( sent_size < 0 ) {
	std::cerr << "cannot send query" << std::endl;
	std::exit( 1 );
    }
    boost::uint8_t response[65536];
    read( tcp_socket, response, sizeof(response) );
    close( tcp_socket );

}

void queries()
{
    for ( int i = 0 ; ; i++ ) {
	std::string qname = "";
	for ( int i = 0 ; i < 32000 ; i++ ) {
	    qname.push_back( 'a' + rand()%26 ); 
	    qname.push_back( '.' );
	}
	qname.push_back( 'a' + rand()%26 ); 

	query( qname );
	sleep( 1 );
    }
}


int
main(int argc, char **argv )
{

    std::vector<boost::shared_ptr<boost::thread> > query_threads;
    for( int i = 0 ; i < MAX_THREADS ; i++ ) {
	query_threads.push_back( boost::shared_ptr<boost::thread>( new boost::thread( queries ) ) );
    }

    for( int i = 0 ; i < MAX_THREADS ; i++ ) {
	query_threads[i]->join();
    }
    boost::thread th( queries );
    th.join();
    return 0;
}
