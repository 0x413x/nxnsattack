#include "dns.hpp"
#include <cstdio>
#include <cstring>
#include <vector>
#include <string>
#include <sstream>
#include <stdexcept>
#include <iostream>
#include <algorithm>
#include <iterator>
#include <arpa/inet.h>
#include <unistd.h>
#include <boost/cstdint.hpp>
#include <boost/shared_ptr.hpp>
#include <boost/numeric/conversion/cast.hpp>
#include <boost/thread.hpp>

const char *DNS_SERVER_ADDRESS = "192.168.33.13";
const int MAX_THREADS = 1;
/*
typedef uint16_t Class;
const Class CLASS_IN = 1;

typedef uint16_t Type;
const Type TYPE_A    = 1;
const Type TYPE_NS   = 2;
const Type TYPE_SOA  = 6;
const Type TYPE_AAAA = 28;
const Type TYPE_AXFR = 252;
class ResourceData;
typedef boost::shared_ptr<ResourceData> ResourceDataPtr;

class ResourceData
{
public:
    virtual ~ResourceData() {}

    virtual std::string toString() const = 0;
    virtual std::vector<boost::uint8_t> getPacket() const = 0;
    virtual Type type() const = 0;
};


class RecordA : public ResourceData
{
private:
    boost::uint32_t sin_addr;

public:
    RecordA( boost::uint32_t sin_addr );
    RecordA( const std::string &address );

    virtual std::string toString() const;
    virtual std::vector<boost::uint8_t> getPacket() const;
    virtual Type type() const
    {
	return TYPE_A;
    }

    static ResourceDataPtr parse( const boost::uint8_t *begin, const boost::uint8_t *end );
};


struct QuestionSectionEntry
{
    std::string q_domainname;
    uint16_t    q_type;
    uint16_t    q_class;
    uint16_t    q_offset;      // for compression
};

struct QueryPacketInfo
{
    boost::uint16_t id;
    bool            recursion;
    std::vector<QuestionSectionEntry> question_section;
};

struct PacketInfo
{
    boost::uint16_t id;

    boost::uint8_t  query_response;
    boost::uint8_t  opcode;
    bool            authoritative_answer;
    bool            truncation;
    bool            recursion_desired;

    bool            recursion_available;
    bool            checking_disabled;
    boost::uint8_t  response_code;

    std::vector<QuestionSectionEntry> question_section;
    //    std::vector<ResponseSectionEntry> answer_section;
    //    std::vector<ResponseSectionEntry> authority_section;
    //    std::vector<ResponseSectionEntry> additional_infomation_section;
};


struct PacketHeaderField
{
    boost::uint16_t id;

    boost::uint8_t  recursion_desired:    1;
    boost::uint8_t  truncation:           1;
    boost::uint8_t  authoritative_answer: 1;
    boost::uint8_t  opcode:               4;
    boost::uint8_t  query_response:       1;

    boost::uint8_t  response_code:        4;
    boost::uint8_t  checking_disabled:    1;
    boost::uint8_t  authentic_data:       1;
    boost::uint8_t  zero_field:           1;
    boost::uint8_t  recursion_available:  1;

    boost::uint16_t question_count;
    boost::uint16_t answer_count;
    boost::uint16_t authority_count;
    boost::uint16_t additional_infomation_count;
};


template<typename Type>
boost::uint8_t *set_bytes( Type v, boost::uint8_t *pos )
{
    *reinterpret_cast<Type *>( pos ) = v;
    return pos + sizeof(v);
}

std::vector<boost::uint8_t> gen_dns_query_packet( const QueryPacketInfo &query );
std::vector<boost::uint8_t> gen_question_section_entry( const QuestionSectionEntry &question );
std::vector<boost::uint8_t> convert_domainname_string_to_binary( const std::string &domainname, uint16_t reference_offset );

std::vector<boost::uint8_t> gen_dns_query_packet( const QueryPacketInfo &query )
{
    PacketHeaderField header;
    header.id                   = htons( query.id );
    header.opcode               = 0;
    header.query_response       = 0;
    header.authoritative_answer = 0;
    header.truncation           = 0;
    header.recursion_desired    = query.recursion;
    header.recursion_available  = 0;
    header.zero_field           = 0;
    header.authentic_data       = 0;
    header.checking_disabled    = 0;
    header.response_code        = 0;

    header.question_count              = htons( query.question_section.size() );
    header.answer_count                = htons( 0 );
    header.authority_count             = htons( 0 );
    header.additional_infomation_count = htons( 0 );

    std::vector<boost::uint8_t> packet;
    std::copy( (boost::uint8_t *)&header, (boost::uint8_t *)&header + sizeof(header), std::back_inserter( packet ) );

    for( std::vector<QuestionSectionEntry>::const_iterator i = query.question_section.begin() ;
	 i != query.question_section.end() ; ++i ) {
	std::vector<boost::uint8_t> question = gen_question_section_entry( *i );
	std::copy( question.begin(), question.end(), std::back_inserter( packet ) );
    }

    return packet;
}

std::vector<boost::uint8_t> convert_domainname_string_to_binary( const std::string &domainname, uint16_t reference_offset )
{
    std::vector<boost::uint8_t> bin;
    std::vector<boost::uint8_t> label;

    for( std::string::const_iterator i = domainname.begin() ; i != domainname.end() ; ++i ) {
	if ( *i == '.' ) {
	    if ( label.size() != 0 ) {
		bin.push_back( boost::numeric_cast<boost::uint8_t>( label.size() ) );
		bin.insert( bin.end(), label.begin(), label.end() );
		label.clear();
	    }
	}
	else {
	    //label.push_back( boost::numeric_cast<boost::uint8_t>( '.' ) );
	    label.push_back( boost::numeric_cast<boost::uint8_t>( *i ) );
	}
    }
    if ( ! label.empty() ) {
	bin.push_back( boost::numeric_cast<boost::uint8_t>( label.size() ) );
	bin.insert( bin.end(), label.begin(), label.end() );
	if ( reference_offset != 0xffff ) {
	    bin.push_back( 0xC0 | ( reference_offset >> 8 ) );  
	    bin.push_back( 0xff & reference_offset );  
	}
	else {
	    bin.push_back( 0 );
	}
    }

    return bin;
}


std::vector<boost::uint8_t> gen_question_section_entry( const QuestionSectionEntry &question )
{
    std::vector<boost::uint8_t> packet = convert_domainname_string_to_binary( question.q_domainname, question.q_offset );
    packet.resize( packet.size() + sizeof(boost::uint16_t) + sizeof(boost::uint16_t) );
    boost::uint8_t *p = packet.data() + packet.size() - sizeof(boost::uint16_t) - sizeof(boost::uint16_t);
    p = set_bytes<boost::uint16_t>( htons( question.q_type ),  p );
    p = set_bytes<boost::uint16_t>( htons( question.q_class ), p );

    return packet;
}

*/

void query( const std::string &qname )
{
    dns::PacketInfo query;
    query.id                   = rand()&0xffff;
    query.opcode               = 0;
    query.query_response       = 0;
    query.authoritative_answer = 0;
    query.truncation           = 0;
    query.recursion_desired    = 1;
    query.recursion_available  = 0;
    query.zero_field           = 0;
    query.authentic_data       = 0;
    query.checking_disabled    = 0;
    query.response_code        = 0;

    dns::QuestionSectionEntry question;
    question.q_domainname = qname;
    question.q_type       = dns::TYPE_A;
    question.q_class      = dns::CLASS_IN;
    question.q_offset     = 0xffff;
    query.question_section.push_back( question );

    WireFormat message;
    dns::generate_dns_packet( query, message );
    std::vector<uint8_t> packet_data = message.get();
    
    int tcp_socket = socket( AF_INET, SOCK_STREAM, IPPROTO_TCP );
    if ( tcp_socket < 0 ) {
	std::cerr << "cannot create socket" << std::endl;
	std::exit( 1 );
    }

    in_addr server_address;
    if ( inet_pton( AF_INET, DNS_SERVER_ADDRESS, &server_address ) <= 0 ) {
	std::cerr << "cannot convert dns server address" << std::endl;
	std::exit( 1 );
    }

    sockaddr_in socket_address;
    std::memset( &socket_address, 0, sizeof(socket_address) );
    socket_address.sin_family = AF_INET;
    socket_address.sin_addr   = server_address;
    socket_address.sin_port   = htons( 53 );
    if ( connect( tcp_socket, reinterpret_cast<const sockaddr *>( &socket_address ), sizeof(socket_address) ) < 0 ) {
	close( tcp_socket );
	std::cerr << "cannot connect to dns server" << std::endl;
	std::exit( 1 );
    }

    boost::uint16_t query_size = htons( boost::numeric_cast<boost::uint16_t>( packet_data.size() ) );
    int sent_size = write( tcp_socket, &query_size, sizeof(query_size) );
    if ( sent_size < 0 ) {
	std::cerr << "cannot end query length" << std::endl;
	std::exit( 1 );
    }
    sent_size = write( tcp_socket, &packet_data[0], packet_data.size() );
    if ( sent_size < 0 ) {
	std::cerr << "cannot send query" << std::endl;
	std::exit( 1 );
    }
    boost::uint8_t response[65536];
    read( tcp_socket, response, sizeof(response) );
    close( tcp_socket );

}

void queries()
{
    for ( int i = 0 ; ; i++ ) {
	std::string qname = "";
	for ( int i = 0 ; i < 32000 ; i++ ) {
	    qname.push_back( 'a' + rand()%26 ); 
	    qname.push_back( '.' );
	}
	qname.push_back( 'a' + rand()%26 ); 

	query( qname );
	sleep( 1 );
    }
}


int
main(int argc, char **argv )
{

    std::vector<boost::shared_ptr<boost::thread> > query_threads;
    for( int i = 0 ; i < MAX_THREADS ; i++ ) {
	query_threads.push_back( boost::shared_ptr<boost::thread>( new boost::thread( queries ) ) );
    }

    for( int i = 0 ; i < MAX_THREADS ; i++ ) {
	query_threads[i]->join();
    }
    boost::thread th( queries );
    th.join();
    return 0;
}
