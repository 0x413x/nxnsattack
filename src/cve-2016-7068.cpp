#include "dns.hpp"
#include "tcpv4client.hpp"
#include <algorithm>
#include <arpa/inet.h>
#include <boost/program_options.hpp>
#include <cstring>
#include <iostream>

const char *DNS_SERVER_ADDRESS = "49.212.193.254";

namespace po = boost::program_options;

int main( int argc, char **argv )
{
    std::string target_server = DNS_SERVER_ADDRESS;
    std::string qname;
    unsigned int qdcount;

    po::options_description desc( "EDNS0 Validation Tester" );
    desc.add_options()( "help,h", "print this message" )

        ( "server,s",
          po::value<std::string>( &target_server )->default_value( DNS_SERVER_ADDRESS ),
          "target server address" )

	( "qdcount,c", po::value<unsigned int>( &qdcount )->default_value( 10 ), "QDCOUNT" )
        ;

    po::variables_map vm;
    po::store( po::parse_command_line( argc, argv, desc ), vm );
    po::notify( vm );

    if ( vm.count( "help" ) ) {
        std::cerr << desc << "\n";
        return 1;
    }

    dns::PacketInfo                        packet_info;
    std::vector<dns::QuestionSectionEntry> question_section;
    std::vector<dns::ResponseSectionEntry> answer_section, authority_section, additional_infomation_section;

    qname = "a";
    for ( int i = 0 ; i < 15000 ; i++ ) 
	qname += ".a";

    dns::QuestionSectionEntry question1;
    question1.q_domainname = qname;
    question1.q_type       = dns::TYPE_A;
    question1.q_class      = dns::CLASS_IN;
    packet_info.question_section.push_back( question1 );

    for ( unsigned int i = 0 ; i < qdcount ; i++ ) {
	dns::QuestionSectionEntry question2;
	question2.q_domainname = "a";
	question2.q_type       = dns::TYPE_A;
	question2.q_class      = dns::CLASS_IN;
	question2.q_offset     = sizeof(dns::PacketHeaderField);
	packet_info.question_section.push_back( question2 );
    }
    
    packet_info.id                   = 1234;
    packet_info.opcode               = 0;
    packet_info.query_response       = 0;
    packet_info.authoritative_answer = 0;
    packet_info.truncation           = 0;
    packet_info.recursion_desired    = 1;
    packet_info.recursion_available  = 0;
    packet_info.zero_field           = 0;
    packet_info.authentic_data       = 0;
    packet_info.checking_disabled    = 0;
    packet_info.response_code        = 0;

    WireFormat message;
    dns::generate_dns_packet( packet_info, message );

    tcpv4::ClientParameters tcp_param;
    tcp_param.destination_address = target_server;
    tcp_param.destination_port    = 53;
    tcpv4::Client tcp( tcp_param );
    uint16_t      data_size = htons( boost::numeric_cast<uint16_t>( message.size() ) );
    tcp.send( reinterpret_cast<uint8_t *>( &data_size ), 2 );
    tcp.send( message );

    tcpv4::ConnectionInfo received_packet = tcp.receive();
    std::cerr << received_packet.end() - received_packet.begin() << std::endl;
    tcp.closeSocket();

    return 0;
}
